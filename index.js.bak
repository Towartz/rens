require('./data')
const fs = require('fs')
const util = require('util')
const os = require('os')
const speed = require('performance-now')
const { exec } = require("child_process")
const { formatp, runtime, jsonformat, isUrl, getRandom, getGroupAdmins } = require('./lib/myFunc')

module.exports = client = async (client, m, chatUpdate, store) => {
    try {
        const body = (m.mtype === 'conversation') ? m.message.conversation : (m.mtype == 'imageMessage') ? m.message.imageMessage.caption : (m.mtype == 'videoMessage') ? m.message.videoMessage.caption : (m.mtype == 'extendedTextMessage') ? m.message.extendedTextMessage.text : (m.mtype == 'buttonsResponseMessage') ? m.message.buttonsResponseMessage.selectedButtonId : (m.mtype == 'listResponseMessage') ? m.message.listResponseMessage.singleSelectReply.selectedRowId : (m.mtype == 'templateButtonReplyMessage') ? m.message.templateButtonReplyMessage.selectedId : (m.mtype === 'messageContextInfo') ? (m.message.buttonsResponseMessage?.selectedButtonId || m.message.listResponseMessage?.singleSelectReply.selectedRowId || m.text) : ''
        const budy = (typeof m.text == 'string' ? m.text : '')
        const prefix = /^[Â°â€¢Ï€Ã·Ã—Â¶âˆ†Â£Â¢â‚¬Â¥Â®â„¢+âœ“_=|~!?@#$%^&.Â©^]/gi.test(body) ? body.match(/^[Â°â€¢Ï€Ã·Ã—Â¶âˆ†Â£Â¢â‚¬Â¥Â®â„¢+âœ“_=|~!?@#$%^&.Â©^]/gi)[0] : ''
        const command = body.replace(prefix, '').trim().split(/ +/).shift().toLowerCase()
        const args = body.trim().split(/ +/).slice(1)
        const botNumber = await client.decodeJid(client.user.id)
        const isOwner = [botNumber, '6283162498175'].map(v => v.replace(/[^0-9]/g, '') + '@s.whatsapp.net').includes(m.sender)
        const pushname = m.pushName || "No Name"
        const typq = (m.quoted || m)
        const quoted = (typq.mtype == 'buttonsMessage') ? typq[Object.keys(typq)[1]] : (typq.mtype == 'templateMessage') ? typq.hydratedTemplate[Object.keys(typq.hydratedTemplate)[1]] : (typq.mtype == 'product') ? typq[Object.keys(typq)[0]] : m.quoted ? m.quoted : m
        const mime = (quoted.msg || quoted).mimetype || ''
        const qmsg = (quoted.msg || quoted)
        const text = q = args.join(" ")
        // custom nya sebelah sini coegg
        const deploy = (teks) => {
       client.relayMessage(m.chat, { requestPaymentMessage: { Message: { extendedTextMessage: { text: teks, currencyCodeIso4217: 'IDR', requestFrom: '0@s.whatsapp.net', expiryTimestamp: 8000, amount: 1, background: thumb }}}}, {})}

        const { BufferJSON, WA_DEFAULT_EPHEMERAL, generateWAMessageFromContent, proto, generateWAMessageContent, generateWAMessage, prepareWAMessageMedia, areJidsSameUser, getContentType } = require('@adiwajshing/baileys')
        
        var sticWait = (hehe) => {
ano = fs.readFileSync('./lib/wait.webp')
client.sendImageAsSticker(m.chat, ano, m, { packname: global.packname, author: global.author })
}

/*
Custom here
*/
/*const ag = {
         contextInfo: { externalAdReply: { showAdAttribution: true,
            mediaUrl: "https://telegra.ph/file/b86a5ffe992bfc72116d7.jpg",
            mediaType: "PHOTO",
            description: "Yoww", 
            title: 'Hello Sir',
            body: 'Yoww',
            thumbnailUrl: "https://telegra.ph/file/b86a5ffe992bfc72116d7.jpg",
            sourceUrl: "https://enxionxv.go.studio/"
    }
    } }
*/
const qtod = m.quoted? "true":"false"
global.thumb = fs.readFileSync("./lib/waifu.jpg")

const Dimage = fs.readFileSync ('./image/D.jpg')


const pay = (teks) => {
  client.relayMessage(m.chat, { requestPaymentMessage: { Message: { extendedTextMessage: { text: teks, currencyCodeIso4217: 'IDR', requestFrom: '0@s.whatsapp.net', expiryTimestamp: 8000, amount1000: 1, background: thumb }}}}, {})
}
/*

let mentionUser = [...new Set([...(m.mentionedJid || []), ...(m.quoted ? [m.quoted.sender] : [])])]
for (let jid of mentionUser) {
let user = global.db.data.users[jid]
if (!user) continue
let afkTime = user.afkTime
if (!afkTime || afkTime < 0) continue
let reason = user.afkReason || ''
m.reply(`
Apakah Ada Yang Ingin Di Tanyakan ${reason ? 'Ada Yang Bisa Saya Bantu? ' + reason : 'Terima Kasih'}
Waktu ${clockString(new Date - afkTime)}
`.trim())
}
if (db.data.users[m.sender].afkTime > -1) {
let user = global.db.data.users[m.sender]
m.reply(`
Hello Saya Bot Hw Mods${user.afkReason ? ' Baiklah ' + user.afkReason : ''}
Selama ${clockString(new Date - user.afkTime)}
`.trim())
user.afkTime = -1
user.afkReason = ''
}
*/

        // Group
        const groupMetadata = m.isGroup ? await client.groupMetadata(m.chat).catch(e => {}) : ''
        const groupName = m.isGroup ? groupMetadata.subject : ''
        const participants = m.isGroup ? await groupMetadata.participants : ''
        const groupAdmins = m.isGroup ? await getGroupAdmins(participants) : ''
        const isBotAdmins = m.isGroup ? groupAdmins.includes(botNumber) : false
        const isAdmins = m.isGroup ? groupAdmins.includes(m.sender) : false

        switch (command) {
            case "tes": {
                m.reply(`Kenapa Kak ${pushname}`)
                }
                break
            case 'q': case 'quoted': {
                if (!isOwner) return m.reply(mess.owner)
                if (!m.quoted) return m.reply('Reply Pesannya!!')
                let getQuoted = await client.serializeM(await m.getQuotedObj())
                if (!getQuoted.quoted) return m.reply('Pesan yang anda reply tidak mengandung reply')
                await getQuoted.quoted.copyNForward(m.chat, true)
                }
                break
            case 'sticker': case 's': case 'stickergif': case 'sgif': {
                if (/image/.test(mime)) {
                    m.reply('Wait â³')
                    let media = await client.downloadMediaMessage(qmsg)
                    let encmedia = await client.sendImageAsSticker(m.chat, media, m, { packname: global.packname, author: global.author })
                    await fs.unlinkSync(encmedia)
                } else if (/video/.test(mime)) {
                    m.reply('Wait â³')
                    if (qmsg.seconds > 11) return m.reply('Maksimal 10 detik!')
                    let media = await client.downloadMediaMessage(qmsg)
                    let encmedia = await client.sendVideoAsSticker(m.chat, media, m, { packname: global.packname, author: global.author })
                    await fs.unlinkSync(encmedia)
                } else {
                    m.reply(`Kirim/reply gambar/video/gif dengan caption ${prefix + command}\nDurasi Video/Gif 1-9 Detik`)
                }}
                break
            case 'setexif': {
                if (!isOwner) return m.reply(mess.owner)
                if (!text) throw `Example : ${prefix + command} packname|author`
                global.packname = text.split("|")[0]
                global.author = text.split("|")[1]
                m.reply(`Exif berhasil diubah menjadi\n\nPackname : ${global.packname}\nAuthor : ${global.author}`)
                }
                break
            case 'stickerwm': case 'swm': case 'stickergifwm': case 'sgifwm': {
                let [teks1, teks2] = text.split`|`
                if (!teks1) throw `Kirim/reply image/video dengan caption ${prefix + command} teks1|teks2`
                if (!teks2) throw `Kirim/reply image/video dengan caption ${prefix + command} teks1|teks2`
            	m.reply('Wait â³')
                if (/image/.test(mime)) {
                    let media = await client.downloadMediaMessage(qmsg)
                    let encmedia = await client.sendImageAsSticker(m.chat, media, m, { packname: teks1, author: teks2 })
                    await fs.unlinkSync(encmedia)
                } else if (/video/.test(mime)) {
                    if ((quoted.msg || quoted).seconds > 11) return m.reply('Maksimal 10 detik!')
                    let media = await client.downloadMediaMessage(qmsg)
                    let encmedia = await client.sendVideoAsSticker(m.chat, media, m, { packname: teks1, author: teks2 })
                    await fs.unlinkSync(encmedia)
                } else {
                    throw `Kirim Gambar/Video Dengan Caption ${prefix + command}\nDurasi Video 1-9 Detik`
                }}
                break
            case 'toimage': case 'toimg': {
                if (!/webp/.test(mime)) throw `Reply sticker dengan caption *${prefix + command}*`
                m.reply('Wait â³')
                let media = await client.downloadAndSaveMediaMessage(qmsg)
                let ran = await getRandom('.png')
                exec(`ffmpeg -i ${media} ${ran}`, (err) => {
                    fs.unlinkSync(media)
                    if (err) throw err
                    let buffer = fs.readFileSync(ran)
                    client.sendMessage(m.chat, { image: buffer }, { quoted: m })
                    fs.unlinkSync(ran)
                })}
                break
            case 'ping': case 'botstatus': case 'statusbot': {
                const used = process.memoryUsage()
                const cpus = os.cpus().map(cpu => {
                    cpu.total = Object.keys(cpu.times).reduce((last, type) => last + cpu.times[type], 0)
                    return cpu
                })
                const cpu = cpus.reduce((last, cpu, _, { length }) => {
                    last.total += cpu.total
                    last.speed += cpu.speed / length
                    last.times.user += cpu.times.user
                    last.times.nice += cpu.times.nice
                    last.times.sys += cpu.times.sys
                    last.times.idle += cpu.times.idle
                    last.times.irq += cpu.times.irq
                    return last
                }, {
                    speed: 0,
                    total: 0,
                    times: {
                        user: 0,
                        nice: 0,
                        sys: 0,
                        idle: 0,
                        irq: 0
                      }
                    })
                let timestamp = speed()
                let latensi = speed() - timestamp
                neww = performance.now()
                oldd = performance.now()
                respon = `\nKecepatan Respon ${latensi.toFixed(4)} Second\n ${oldd - neww} Miliseconds\n\nRuntime : ${runtime(process.uptime())}\n\nðŸ—ƒï¸ Info Server\nRAM: ${formatp(os.totalmem() - os.freemem())} / ${formatp(os.totalmem())}\n\nNodeJS Memory Usaage\n${Object.keys(used).map((key, _, arr) => `${key.padEnd(Math.max(...arr.map(v=>v.length)),' ')}: ${formatp(used[key])}`).join('\n')}\n\n${cpus[0] ? `Total CPU Usage\n${cpus[0].model.trim()} (${cpu.speed} MHZ)\n${Object.keys(cpu.times).map(type => `- ${(type + ' ').padEnd(6)}: ${(100 * cpu.times[type] / cpu.total).toFixed(2)}%`).join('\n')}\nCPU Core(s) Usage (${cpus.length} Core CPU)\n${cpus.map((cpu, i) => `${i + 1}. ${cpu.model.trim()} (${cpu.speed} MHZ)\n${Object.keys(cpu.times).map(type => `- ${(type + ' ').padEnd(6)}: ${(100 * cpu.times[type] / cpu.total).toFixed(2)}%`).join('\n')}`).join('\n\n')}` : ''}`.trim()
                m.reply(respon)
                }
                break
            case 'speedtest': {
                m.reply('Testing Speed...')
                let cp = require('child_process')
                let { promisify } = require('util')
                let exec = promisify(cp.exec).bind(cp)
                let o
                try {
                    o = await exec('python speed.py')
                } catch (e) {
                    o = e
                } finally {
                    let { stdout, stderr } = o
                    if (stdout.trim()) m.reply(stdout)
                    if (stderr.trim()) m.reply(stderr)
                }}
                break
            case 'owner': case 'me': case 'creator': {
                let vcard = 'BEGIN:VCARD\n'
    + 'VERSION:3.0\n' 
    + 'N:;Diki;;;'
    + 'FN:Diki\n'
    + 'ORG:ð™¸ ð™°ðš– Diki Ganzz;\n' //Nama Kalian
    + 'item1.TEL;type=CELL;type=VOICE;waid=6283162498175:+62 831-6249-8175\n' //Nomor Kalian
    + 'item1.X-ABLabel: Introvert, Programmers, Modder & Content Creators YouTube \n' //Info Kalian
    + 'item5.X-ABLabel: Subscribe My Channel 66XZD !! \n' //Info Kalian
    + 'item6.X-ABLabel: No Ambition = No Results \n' //Info Kalian
    + 'item2.EMAIL;type=INTERNET:66xzd.hz@gmail.com\n' // Email Kalian
    + 'item2.X-ABLabel:Email\n'
    + 'item3.URL:https://enxionxv.go.studio/\n' //Ig Kalian Atau Web Kalian
    + 'item3.X-ABLabel:Website\n'
    + 'item4.ADR:;;West Java, Indonesia;;;;\n' //Negara Kalian
    + 'item4.X-ABLabel:Region\n'
    + 'END:VCARD'
client.sendMessage(m.chat, { contacts: { displayName: 'ð™¸ ð™°ðš– Diki', contacts: [{ vcard }] } }, { quoted: m })
            }
break 

            case 'join': {
                if (!isOwner) return m.reply(mess.owner)
                if (!text) throw 'Masukkan Link Group!'
                if (!isUrl(args[0]) && !args[0].includes('whatsapp.com')) throw 'Link Invalid!'
                m.reply(mess.wait)
                let result = args[0].split('https://chat.whatsapp.com/')[1]
                await client.groupAcceptInvite(result).then((res) => m.reply(jsonformat(res))).catch((err) => m.reply(jsonformat(err)))
                }
                break
            case 'leave': {
                if (!isOwner) return m.reply(mess.owner)
                await client.groupLeave(m.chat).then((res) => m.reply(jsonformat(res))).catch((err) => m.reply(jsonformat(err)))
                }
                break
            case 'kick': {
                if (!m.isGroup) throw mess.group
                if (!isBotAdmins) throw mess.botAdmin
                if (!isAdmins) throw mess.admin
                let users = m.mentionedJid[0] ? m.mentionedJid : m.quoted ? [m.quoted.sender] : [text.replace(/[^0-9]/g, '')+'@s.whatsapp.net']
                await client.groupParticipantsUpdate(m.chat, users, 'remove').then((res) => m.reply(jsonformat(res))).catch((err) => m.reply(jsonformat(err)))
                }
                break
            case 'add': {
                if (!m.isGroup) throw mess.group
                if (!isBotAdmins) throw mess.botAdmin
                if (!isAdmins) throw mess.admin
                let users = m.mentionedJid[0] ? m.mentionedJid : m.quoted ? [m.quoted.sender] : [text.replace(/[^0-9]/g, '')+'@s.whatsapp.net']
                await client.groupParticipantsUpdate(m.chat, users, 'add').then((res) => m.reply(jsonformat(res))).catch((err) => m.reply(jsonformat(err)))
                }
                break
            case 'promote': {
                if (!m.isGroup) throw mess.group
                if (!isBotAdmins) throw mess.botAdmin
                if (!isAdmins) throw mess.admin
                let users = m.mentionedJid[0] ? m.mentionedJid : m.quoted ? [m.quoted.sender] : [text.replace(/[^0-9]/g, '')+'@s.whatsapp.net']
                await client.groupParticipantsUpdate(m.chat, users, 'promote').then((res) => m.reply(jsonformat(res))).catch((err) => m.reply(jsonformat(err)))
                }
                break
            case 'demote': {
                if (!m.isGroup) throw mess.group
                if (!isBotAdmins) throw mess.botAdmin
                if (!isAdmins) throw mess.admin
                let users = m.mentionedJid[0] ? m.mentionedJid : m.quoted ? [m.quoted.sender] : [text.replace(/[^0-9]/g, '')+'@s.whatsapp.net']
                await client.groupParticipantsUpdate(m.chat, users, 'demote').then((res) => m.reply(jsonformat(res))).catch((err) => m.reply(jsonformat(err)))
                }
                break
            case 'block': {
                if (!isOwner) return m.reply(mess.owner)
                let users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '')+'@s.whatsapp.net'
                await client.updateBlockStatus(users, 'block').then((res) => m.reply(jsonformat(res))).catch((err) => m.reply(jsonformat(err)))
                }
                break
            case 'unblock': {
                if (!isOwner) return m.reply(mess.owner)
                let users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '')+'@s.whatsapp.net'
                await client.updateBlockStatus(users, 'unblock').then((res) => m.reply(jsonformat(res))).catch((err) => m.reply(jsonformat(err)))
                }
                break
            case 'setname': case 'setsubject': {
                if (!m.isGroup) throw mess.group
                if (!isBotAdmins) throw mess.botAdmin
                if (!isAdmins) throw mess.admin
                if (!text) throw 'Text ?'
                await client.groupUpdateSubject(m.chat, text).then((res) => m.reply(mess.success)).catch((err) => m.reply(jsonformat(err)))
                }
                break
            case 'setdesc': case 'setdesk': {
                if (!m.isGroup) throw mess.group
                if (!isBotAdmins) throw mess.botAdmin
                if (!isAdmins) throw mess.admin
                if (!text) throw 'Text ?'
                await client.groupUpdateDescription(m.chat, text).then((res) => m.reply(mess.success)).catch((err) => m.reply(jsonformat(err)))
                }
                break
            case 'setppbot': {
                if (!isOwner) return m.reply(mess.owner)
                if (!/image/.test(mime)) throw `Kirim/Reply Image Dengan Caption ${prefix + command}`
                if (/webp/.test(mime)) throw `Kirim/Reply Image Dengan Caption ${prefix + command}`
                let media = await client.downloadAndSaveMediaMessage(qmsg)
                await client.updateProfilePicture(botNumber, { url: media }).catch((err) => fs.unlinkSync(media))
                m.reply(mess.success)
                }
                break
            case 'setppgroup': case 'setppgrup': case 'setppgc': {
                if (!m.isGroup) throw mess.group
                if (!isAdmins) throw mess.admin
                if (!isOwner) return m.reply(mess.owner)
                if (!/image/.test(mime)) throw `Kirim/Reply Image Dengan Caption ${prefix + command}`
                if (/webp/.test(mime)) throw `Kirim/Reply Image Dengan Caption ${prefix + command}`
                let media = await client.downloadAndSaveMediaMessage(qmsg)
                await client.updateProfilePicture(m.chat, { url: media }).catch((err) => fs.unlinkSync(media))
                m.reply(mess.success)
                }
                break
            case 'tagall': {
                if (!isOwner) return m.reply(mess.owner)
                if (!m.isGroup) throw mess.group
                if (!isBotAdmins) throw mess.botAdmin
                if (!isAdmins) throw mess.admin
                let teks = `â•â•âœªã€˜ Tag All Participant ã€™âœªâ•â•\n\nâž² Pesan : ${q ? q : 'Tanpa Pesan'}\n\n`
                for (let mem of participants) {
                teks += `=> @${mem.id.split('@')[0]}\n`
                }
                client.sendMessage(m.chat, { text: teks, mentions: participants.map(a => a.id) }, { quoted: m })
                }
                break
            case 'hidetag': {
                if (!isOwner) return m.reply(mess.owner)
                if (!m.isGroup) throw mess.group
                if (!isBotAdmins) throw mess.botAdmin
                if (!isAdmins) throw mess.admin
                client.sendMessage(m.chat, { text : q ? q : 'Hi' , mentions: participants.map(a => a.id)}, { quoted: m })
                }
                break

case 'react':
    {
        reactionMessage = {
            react: {
                text: args[0],
                key: {
                    remoteJid: m.chat,
                    fromMe: false,
                    id: quoted.id
                }
            }
        }
        client.sendMessage(m.chat, reactionMessage)
    }
    break
case 'poll': {
if (!isOwner) return m.reply(mess.owner)
var pollCreation = generateWAMessageFromContent(m.chat, proto.Message.fromObject({
"pollCreationMessage": {
"name": "HALO ðŸ‘‹ SAYA BOT D2V CHAN",
"options": [
	{
"optionName": "OP1"
	},
	{
"optionName": "OP2"
	},
	{
"optionName": "OP3"
	},
	{
"optionName": "OP4"
	},
	{
"optionName": "OP5"
	},
	{
"optionName": "OP6"
	},
	{
"optionName": "OP7"
	},
	{
"optionName": "OP8"
	},
	{
"optionName": "OP9"
	},
	{
"optionName": "OP10"
	},
	{
"optionName": "OP11"
	},
	{
"optionName": "OP12"
	}
],
"selectableOptionsCount": 12
	}
}), { userJid: m.chat })
client.relayMessage(m.chat, pollCreation.message, { messageId: pollCreation.key.id })
}
break

case 'once': case 'toonce': { 
if (!isOwner) return m.reply(mess.owner)
if (!quoted) throw 'Reply Image'
if (/image/.test(mime)) {
anu = await client.downloadAndSaveMediaMessage(quoted)
client.sendMessage(m.chat, {image: {url: anu},viewOnce : true})
} else if (/video/.test(mime)) {
anu = await client.downloadAndSaveMediaMessage(quoted)
client.sendMessage(m.chat, {video: {url: anu},viewOnce : true})
}
}
break
                // Ini buat slef Dan public
            case 'public': case 'pub': {
                if (!isOwner) return m.reply(mess.owner)
                client.public = true
                m.reply('Sukse Change To Public Usage')
            }
            break
            case 'self': {
                if (!isOwner) return m.reply(mess.owner)
                client.public = false
                m.reply('Sukses Change To Self Usage')
            }
            break
            case 'bgz': {
                if (!isOwner) return m.reply(mess.owner)
                pay('Hi Tuan Ku')
            }
            break
            case 'bgz1': {
                if (!isOwner) return m.reply(mess.owner)
                var requestPaymentMessage = generateWAMessageFromContent(m.chat, proto.Message.fromObject({
                "requestPaymentMessage": {
                "currencyCode": "IDR",
                "footerText": ` `,
                "priceAmount1000": "10000000",
                "salePriceAmount1000": "10000000",
                "url": "Wa.me/6285714170944"
                }}), { userJid: m.chat})
                client.relayMessage(m.chat, requestPaymentMessage.message, { messageId: requestPaymentMessage.key.id })
                m.reply(`Success Send`)}
                break
          
           
           


case 'ppb': {
if (!isOwner) return m.reply(mess.owner)
m.reply(mess.wait)
if (!/image/.test(mime)) throw `Kirim/Reply Image Dengan Caption ${prefix + command}`
if (/webp/.test(mime)) throw `Kirim/Reply Image Dengan Caption ${prefix + command}`
var media = await client.downloadAndSaveMediaMessage(quoted)
try {
if (args[0] == "/full") {
const { generateProfilePicture } = require("./lib/myFunc.js")
var { img } = await generateProfilePicture(media)
await client.query({ tag: 'iq',attrs: { to: botNumber, type:'set', xmlns: 'w:profile:picture'}, content: [{ tag: 'picture', attrs: { type: 'image' }, content: img }]})
} else { await client.updateProfilePicture(botNumber, { url: media }) }
m.reply(mess.success)
} catch { m.reply('Gagal Mengganti Photo Profile') }
}
break
case 'ppg': {
if (!isOwner) return m.reply(mess.owner)
m.reply(mess.wait)
if (!/image/.test(mime)) throw `Kirim/Reply Image Dengan Caption ${prefix + command}`
if (/webp/.test(mime)) throw `Kirim/Reply Image Dengan Caption ${prefix + command}`
let media = await client.downloadAndSaveMediaMessage(quoted)
try {
if (args[0] == "/full") {
const { generateProfilePicture } = require("./lib/myFunc.js")
var { img } = await generateProfilePicture(media)
await client.query({ tag: 'iq',attrs: { to: m.chat, type:'set', xmlns: 'w:profile:picture'}, content: [{ tag: 'picture', attrs: { type: 'image' }, content: img }]})
} else { await client.updateProfilePicture(m.chat, { url: media }) }
m.reply(mess.success)
} catch { m.reply('Gagal Mengganti Photo Profile') }
}
break

case 'yo': {
if (!isOwner) return m.reply(mess.owner)
client.sendMessage(m.chat, { image: Dimage, caption: ` Yo What's Up My Owner`,
contextInfo:{
forwardingScore: 9999,
isForwarded: false,
externalAdReply: {"title": `Diki Ganzzz`,"body": `Yow, What's up??`,
previewType: "PHOTO",
showAdAttribution: true,
sourceUrl: `https://wa.me/6283162498175`,
thumbnailUrl: `https://telegra.ph/file/b86a5ffe992bfc72116d7.jpg`, 
thumbnail: Dimage,
}
}})

//m.reply('Yowww',  { userJid: m.chat, quoted: ag })


}
break

    

case 'play': case 'ytplay': {
                if (!text) throw `Example : ${prefix + command} story wa anime`
                m.reply(`Loading...`)
                let yts = require("yt-search")
                let search = await yts(text)
                let anu = search.videos[Math.floor(Math.random() * search.videos.length)]
                let buttons = [
                    {buttonId: `ytmp3 ${anu.url}`, buttonText: {displayText: ' Audio'}, type: 1},
                    {buttonId: `ytmp4 ${anu.url}`, buttonText: {displayText: ' Video'}, type: 1}
                ]
                let buttonMessage = {
                    image: { url: anu.thumbnail },
                    caption: `
âž£ Title : ${anu.title}
âž£ Ext : Search
âž£ ID : ${anu.videoId}
âž£ Duration : ${anu.timestamp}
âž£ Viewers : ${anu.views}
âž£ Upload At : ${anu.ago}
âž£ Author : ${anu.author.name}
âž£ Channel : ${anu.author.url}
âž£ Description : ${anu.description}
âž£ Url : ${anu.url}`,
                    footer: client.user.name,
                    buttons: buttons,
                    headerType: 4
                }
                client.sendMessage(m.chat, buttonMessage, { quoted: m })
            }
            break
case 'ytmp3': case 'ytaudio': {


let { yta } = require('./baseikal/lib/y2mate')
if (!text) throw `Example : ${prefix + command} https://youtube.com/watch?v=PtFMh6Tccag%27 128kbps`
let quality = args[1] ? args[1] : '128kbps'
let media = await yta(text, quality)
if (media.filesize >= 100000) return anjay('File Melebihi Batas '+util.format(media))
haikal.sendImage(m.chat, media.thumb, `â­” Title : ${media.title}\nâ­” File Size : ${media.filesizeF}\nâ­” Url : ${isUrl(text)}\nâ­” Ext : MP3\nâ­” Resolusi : ${args[1] || '128kbps'}`, m)
haikal.sendMessage(m.chat, { audio: { url: media.dl_link }, mimetype: 'audio/mpeg', fileName: `${media.title}.mp3` }, { quoted:hw })
}
break
//=================================================//
case 'ytmp4': case 'ytvideo': {


let { ytv } = require('./baseikal/lib/y2mate')
if (!text) throw `Example : ${prefix + command} https://youtube.com/watch?v=PtFMh6Tccag%27 360p`
let quality = args[1] ? args[1] : '360p'
let media = await ytv(text, quality)
if (media.filesize >= 100000) return anjay('File Melebihi Batas '+util.format(media))
haikal.sendMessage(m.chat, { video: { url: media.dl_link }, mimetype: 'video/mp4', fileName: `${media.title}.mp4`, caption: `â­” Title : ${media.title}\nâ­” File Size : ${media.filesizeF}\nâ­” Url : ${isUrl(text)}\nâ­” Ext : MP3\nâ­” Resolusi : ${args[1] || '360p'}` }, { quoted:hw })
}
break


//=================================================//
case 'getname': {
if (!isOwner) return m.reply(mess.owner)
if (qtod === "true") {
namenye = await client.getName(m.quoted.sender)
m.reply(namenye)
} else if (qtod === "false") {
client.sendMessage(from, {text:"Reply orangnya"})
}
}
break
//=================================================//
case 'getpic': {
if (!isOwner) return m.reply(mess.owner)
if (qtod === "true") {
try {
pporg = await client.profilePictureUrl(m.quoted.sender, 'image')
} catch {
pporg = 'https://i0.wp.com/www.gambarunik.id/wp-content/uploads/2019/06/Top-Gambar-Foto-Profil-Kosong-Lucu-Tergokil-.jpg'
}
client.sendMessage(m.chat, { image : { url : pporg }, caption:`Done` }, { quoted : m })
} else if (qtod === "false") {
try {
pporgs = await client.profilePictureUrl(from, 'image')
} catch {
pporgs = 'https://i0.wp.com/www.gambarunik.id/wp-content/uploads/2019/06/Top-Gambar-Foto-Profil-Kosong-Lucu-Tergokil-.jpg'
}
client.sendMessage(m.chat, { image : { url : pporgs }, caption:`Done` }, { quoted : m })
}
}
break








































// batas break sampe sini coeg
        default:
            if (budy.startsWith('=>')) {
                if (!isOwner) return m.reply(mess.owner)
                function Return(sul) {
                    sat = JSON.stringify(sul, null, 2)
                    bang = util.format(sat)
                if (sat == undefined) {
                    bang = util.format(sul)
                    }
                        return m.reply(bang)
                    }
                try {
                    m.reply(util.format(eval(`(async () => { return ${budy.slice(3)} })()`)))
                } catch (e) {
                    m.reply(String(e))
               }
            }
            if (budy.startsWith('>')) {
                if (!isOwner) return m.reply(mess.owner)
                try {
                    let evaled = await eval(budy.slice(2))
                    if (typeof evaled !== 'string') evaled = require('util').inspect(evaled)
                    await m.reply(evaled)
                } catch (err) {
                    await m.reply(String(err))
                }
            }
            if (budy.startsWith('$')) {
                if (!isOwner) return m.reply(mess.owner)
                exec(budy.slice(2), (err, stdout) => {
                    if (err) return m.reply(`${err}`)
                    if (stdout) return m.reply(stdout)
                })
            }
        }
    } catch (e) {
        m.reply(util.format(e))
    }
}

let file = require.resolve(__filename)
fs.watchFile(file, () => {
	fs.unwatchFile(file)
	console.log(`Update ${__filename}`)
	delete require.cache[file]
	require(file)
})
